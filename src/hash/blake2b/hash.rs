use super::consts::BLAKE2B_OUT_MAX;
use super::core::Blake2b;

/// Computes a Blake2b hash of the given input.
///
/// `out_len` specifies the desired output length in bytes (up to
/// `BLAKE2B_OUT_MAX`).
///
/// The function returns the full Blake2b output; callers may truncate
/// the result to `out_len` bytes if needed.
///
/// This is a one-shot convenience wrapper around the Blake2b compression
/// core, using an empty key.
pub fn blake2b(out_len: usize, input: &[u8]) -> [u8; BLAKE2B_OUT_MAX] {
    assert!(out_len <= BLAKE2B_OUT_MAX);

    let mut h = Blake2b::new(out_len, &[]);

    h.update(input);
    h.finalize()
}

/// Computes a Blake2b-based extendable-output hash (XOF).
///
/// This function expands the given input into an output of arbitrary length
/// using chained Blake2b invocations, following the construction defined
/// in the Argon2 specification.
///
/// The output length is encoded in little-endian form and prepended to the
/// input to ensure domain separation. For output lengths up to
/// `BLAKE2B_OUT_MAX`, a single Blake2b invocation is used. Longer outputs
/// are generated by iteratively hashing intermediate values.
///
/// This is a low-level cryptographic primitive intended for internal use
/// in higher-level constructions (e.g. memory-hard functions).
pub fn blake2b_long(out_len: usize, input: &[u8]) -> Vec<u8> {
    let t_le = (out_len as u32).to_le_bytes();

    if out_len <= BLAKE2B_OUT_MAX {
        let mut buf = Vec::with_capacity(4 + input.len());

        buf.extend_from_slice(&t_le);
        buf.extend_from_slice(input);

        return blake2b(out_len, &buf)[..out_len].to_vec();
    }

    // For longer outputs:
    // 1. First hash: V0 = H^64(len || input)
    // 2. Output first 32 bytes of V0
    // 3. While remaining > 64: Vi = H^64(V_{i-1}), output first 32 bytes
    // 4. Last block: H^r(V_last) where r = remaining length

    let mut x = Vec::with_capacity(4 + input.len());
    x.extend_from_slice(&t_le);
    x.extend_from_slice(input);

    let mut last_output = blake2b(BLAKE2B_OUT_MAX, &x);
    let mut out = Vec::with_capacity(out_len);

    // Write first 32 bytes
    out.extend_from_slice(&last_output[..32]);

    // While remaining > 64, keep hashing and writing 32-byte chunks
    while out_len - out.len() > BLAKE2B_OUT_MAX {
        last_output = blake2b(BLAKE2B_OUT_MAX, &last_output);
        out.extend_from_slice(&last_output[..32]);
    }

    // Last block with variable length
    let remaining = out_len - out.len();
    let v_last = blake2b(remaining, &last_output);
    out.extend_from_slice(&v_last[..remaining]);

    out
}
